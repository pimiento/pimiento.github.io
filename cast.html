<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-10-25 Wed 14:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Pavel Vavilin" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="solarized-dark.min.css" />

<script type="text/javascript" src="org-info.min.js">
/**
 *
 * @source: org-info.min.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in org-info.min.js.
 *
 * Copyright (C) 2012-2017 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in org-info.min.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "1");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4575482">1. named casts</a>
<ul>
<li><a href="#org4ab87c6">1.1. static_cast</a></li>
<li><a href="#orgceaa7da">1.2. const_cast</a></li>
<li><a href="#org8b0bff3">1.3. reinterpret_cast</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4575482" class="outline-2">
<h2 id="org4575482"><span class="section-number-2">1</span> named casts</h2>
<div class="outline-text-2" id="text-1">
<p>
Programmers should seriously consider banning C-style casts from their own programs. Where explicit type conversion is necessary, static_cast , reinterpret_cast , const_cast , or a combination of these can do what a C-style cast can. The named casts should be preferred because they are more explicit and more visible.
If you feel tempted to use an explicit type conversion, take the time to consider if it is really necessary. In C++, explicit type conversion is unnecessary in most cases when C needs it and also in many cases in which earlier versions of C++ needed it. In many programs, explicit type conversion can be completely avoided; in others, its use can be localized to a few routines.
</p>
</div>

<div id="outline-container-org4ab87c6" class="outline-3">
<h3 id="org4ab87c6"><span class="section-number-3">1.1</span> static_cast</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A static_cast is used for all conversions that are well-defined. These include “safe” conversions that the compiler would allow you to do without a cast and less-safe conversions that are nonetheless well-defined. The types of conversions covered by static_cast include typical castless conversions, narrowing (information-losing) conversions, forcing a conversion from a void*, implicit type conversions, and static navigation of class hierarchies
</p>
<div class="org-src-container">
<pre class="src src-cpp" id="orgffc2a52"><span style="color: #00ffff;">void</span> <span style="color: #00ffff; font-weight: bold;">func</span>(<span style="color: #00ffff;">int</span>) {}

<span style="color: #00ffff;">int</span> <span style="color: #00ffff; font-weight: bold;">main</span>() {
    <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">i</span> = 0x7fff; <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Max pos value = 32767</span>
    <span style="color: #00ffff;">long</span> <span style="color: #ffffff;">l</span>;
    <span style="color: #00ffff;">float</span> <span style="color: #ffffff;">f</span>;
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">(1) Typical castless conversions:</span>
    l = i;
    f = i;
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Also works:</span>
    l = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">long</span>&gt;(i);
    f = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">float</span>&gt;(i);

    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">(2) Narrowing conversions:</span>
    i = l; <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">May lose digits</span>
    <span style="color: #5F7F5F;">//</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">i = {l}</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">will cause:</span>
    <span style="color: #5F7F5F;">//     </span><span style="color: #ffa500; font-style: italic;">warning: narrowing conversion of &#8216;l&#8217; from &#8216;long int&#8217; to &#8216;int&#8217; inside </span><span style="color: #DC8CC3; background-color: #3F3F3F; font-style: italic;">{ } [-Wnarrowing]</span>
    <span style="color: #5F7F5F;">//</span>
    i = f; <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">May lose info</span>
    <span style="color: #5F7F5F;">//</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">i = {f}</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">will cause:</span>
    <span style="color: #5F7F5F;">//     </span><span style="color: #ffa500; font-style: italic;">warning: narrowing conversion of &#8216;f&#8217; from &#8216;float&#8217; to &#8216;int&#8217; inside { }</span><span style="color: #DC8CC3; background-color: #3F3F3F; font-style: italic;"> [-Wnarrowing]</span>
    <span style="color: #5F7F5F;">//</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Says "I know," eliminates warnings:</span>
    i = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">int</span>&gt;(l);
    i = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">int</span>&gt;(f);
    <span style="color: #00ffff;">char</span> <span style="color: #ffffff;">c</span> = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">char</span>&gt;(i);
    ++c;                        <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">-Wunused-but-set-variable</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">(3) Forcing a conversion from void* :</span>
    <span style="color: #00ffff;">void</span>* <span style="color: #ffffff;">vp</span> = &amp;i;
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Old way produces a dangerous conversion:</span>
    <span style="color: #00ffff;">float</span>* <span style="color: #ffffff;">fp</span> = (<span style="color: #00ffff;">float</span>*)vp;
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">The new way is equally dangerous:</span>
    fp = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">float</span>*&gt;(vp);
    ++(*fp);                    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">-Wunused-but-set-variable</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">(4) Implicit type conversions, normally</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">performed by the compiler:</span>
    <span style="color: #00ffff;">double</span> <span style="color: #ffffff;">d</span> = 0.0;
    <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">x</span> = d; <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Automatic type conversion</span>
    x = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">int</span>&gt;(d); <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">More explicit</span>
    ++x;                     <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">-Wunused-but-set-variable</span>
    func(d); <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Automatic type conversion</span>
    func(<span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">int</span>&gt;(d)); <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">More explicit</span>
} <span style="color: #5F7F5F;">///</span><span style="color: #ffa500; font-style: italic;">:~</span>
</pre>
</div>

<p>
Assigning from a void* is not allowed without a cast in C++ (unlike C). This is dangerous and requires that programmers know what they’re doing. The static_cast, at least, is easier to locate than the old standard cast when you’re hunting for bugs.
</p>
<div class="org-src-container">
<pre class="src src-cpp" id="orgb5e1a73"><span style="color: #00ffff;">void</span>* <span style="color: #ffffff;">vp</span> = &amp;i;
<span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Old way produces a dangerous conversion:</span>
<span style="color: #00ffff;">float</span>* <span style="color: #ffffff;">fp</span> = (<span style="color: #00ffff;">float</span>*)vp;
<span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">The new way is equally dangerous:</span>
fp = <span style="color: #00ff00; font-weight: bold;">static_cast</span>&lt;<span style="color: #00ffff;">float</span>*&gt;(vp);
++(*fp);                    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">-Wunused-but-set-variable</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgceaa7da" class="outline-3">
<h3 id="orgceaa7da"><span class="section-number-3">1.2</span> const_cast</h3>
<div class="outline-text-3" id="text-1-2">
<p>
If you want to convert from a const to a nonconst or from a volatile to a nonvolatile, you use const_cast. This is the only conversion allowed with const_cast; if any other conversion is involved it must be done using a separate expression or you’ll get a compile-time error.
If you take the address of a const object, you produce a pointer to a const, and this cannot be assigned to a nonconst pointer without a cast. The old-style cast will accomplish this, but the const_cast is the appropriate one to use. The same holds true for volatile.
A const_cast changes only a low-level const in its operand.
</p>
<div class="org-src-container">
<pre class="src src-cpp" id="org6c106f8"><span style="color: #00ffff;">int</span> <span style="color: #00ffff; font-weight: bold;">main</span>() {
    <span style="color: #00ff00; font-weight: bold;">const</span> <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">i</span> = 0;
    <span style="color: #00ffff;">int</span>* <span style="color: #ffffff;">j</span> = (<span style="color: #00ffff;">int</span>*)&amp;i;          <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Deprecated old-style form</span>
    j = <span style="color: #00ff00; font-weight: bold;">const_cast</span>&lt;<span style="color: #00ffff;">int</span>*&gt;(&amp;i);   <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Prefered</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Can't do simultaneous additional casting:</span>
    <span style="color: #5F7F5F;">//</span><span style="color: #ffa500; font-style: italic;">! long* l = const_cast&lt;long*&gt;(&amp;i); // Error</span>
    <span style="color: #00ff00; font-weight: bold;">volatile</span> <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">k</span> = 0;
    <span style="color: #00ffff;">int</span>* <span style="color: #ffffff;">u</span> = <span style="color: #00ff00; font-weight: bold;">const_cast</span>&lt;<span style="color: #00ffff;">int</span>*&gt;(&amp;k);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b0bff3" class="outline-3">
<h3 id="org8b0bff3"><span class="section-number-3">1.3</span> reinterpret_cast</h3>
<div class="outline-text-3" id="text-1-3">
<p>
This is the least safe of the casting mechanisms, and the one most likely to produce bugs. A reinterpret_cast pretends that an object is just a bit pattern that can be treated (for some dark purpose) as if it were an entirely different type of object. You’ll virtually always need to reinterpret_cast back to the original type (or otherwise treat the variable as its original type) before doing anything else with it.
</p>

<div class="org-src-container">
<pre class="src src-cpp" id="org7b15be5"><span style="color: #8090A2;">#include</span> <span style="color: #ffa500;">&lt;iostream&gt;</span>
<span style="color: #00ff00; font-weight: bold;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #00ffff;">cout</span>;
<span style="color: #00ff00; font-weight: bold;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #00ffff;">endl</span>;
<span style="color: #00ff00; font-weight: bold;">const</span> <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">sz</span> = 3;

<span style="color: #00ff00; font-weight: bold;">struct</span> <span style="color: #00ffff;">X</span> { <span style="color: #00ffff;">int</span> <span style="color: #ffffff;">a</span>[sz]; };

<span style="color: #00ffff;">void</span> <span style="color: #00ffff; font-weight: bold;">print</span>(<span style="color: #00ffff;">X</span>* <span style="color: #ffffff;">x</span>) {
    <span style="color: #00ff00; font-weight: bold;">for</span> (<span style="color: #00ffff;">int</span> <span style="color: #ffffff;">i</span> = 0; i &lt; sz; ++i)
        cout &lt;&lt; (x-&gt;a)[i] &lt;&lt; <span style="color: #ffa500;">' '</span>;
    cout &lt;&lt; endl;
}

<span style="color: #00ffff;">int</span> <span style="color: #00ffff; font-weight: bold;">main</span>() {
    <span style="color: #00ffff;">X</span> <span style="color: #ffffff;">x</span>;
    print(&amp;x);
    <span style="color: #00ffff;">int</span>* <span style="color: #ffffff;">xp</span> = <span style="color: #00ff00; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">int</span>*&gt;(&amp;x);
    <span style="color: #00ff00; font-weight: bold;">for</span> (<span style="color: #00ffff;">int</span>* <span style="color: #ffffff;">i</span> = xp; i != xp + sz; ++i)
        *i = 0;
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Can't use xp as an X* at this point</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">unless you cast it back</span>
    print(<span style="color: #00ff00; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">X</span>*&gt;(xp));
    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">You can also use just original identifier</span>
    print(&amp;x);

    <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">Stroustrup's example</span>
    <span style="color: #00ffff;">char</span> <span style="color: #ffffff;">c</span> = <span style="color: #ffa500;">'a'</span>;
    <span style="color: #5F7F5F;">//</span><span style="color: #ffa500; font-style: italic;">! int* p1 = &amp;c; // Error: no implicit char* to int* conversion</span>
    <span style="color: #5F7F5F;">//</span><span style="color: #ffa500; font-style: italic;">! int* p2 = static_cast&lt;int*&gt;(&amp;c); // Error: no implicit char* to int* con</span><span style="color: #DC8CC3; background-color: #3F3F3F; font-style: italic;">version</span>
    <span style="color: #00ffff;">int</span>* <span style="color: #ffffff;">p3</span> = <span style="color: #00ff00; font-weight: bold;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">int</span>*&gt;(&amp;c); <span style="color: #5F7F5F;">// </span><span style="color: #ffa500; font-style: italic;">OK: on your head be it</span>
}
</pre>
</div>

<p>
The idea of reinterpret_cast is that when you use it, what you get is so foreign that it cannot be used for the type’s original purpose unless you cast it back. Here, we see the cast back to an X* in the call to print, but of course since you still have the original identifier you can also use that. But the xp is only useful as an int*, which is truly a “reinterpretation” of the original X.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Pavel Vavilin</p>
<p class="date">Created: 2017-10-25 Wed 14:29</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
